#!/usr/bin/env python3
"""
get_highres_images_colmap.py

Update COLMAP images.txt/bin files to reference the high-resolution source image
filenames instead of the downsampled timestamp-based keyframe names.

This enables using full-resolution images for Gaussian splatting while keeping the same
camera poses estimated by MASt3R-SLAM on downsampled images.

Input:
  - keyframe_mapping.txt: Maps timestamp â†’ frame_id â†’ original_filename (from MASt3R-SLAM)
  - images.txt/bin: COLMAP poses for downsampled keyframes

Output:
  - images_lowres.txt/bin: Backup of original images files
  - images.txt/bin: Updated to use high-res filenames (overwrites original)
  - keyframe_mapping_full.txt: Extended mapping with high-res filenames

Usage:
  python get_highres_images_colmap.py --dataset mars_johns_1
  python get_highres_images_colmap.py --dataset mars_johns_1 --mslam_logs_dir /custom/path
"""

import argparse
import struct
import shutil
from pathlib import Path


INTERMEDIATE_DATA_ROOT = Path('/home/ben/encode/data/intermediate_data')


def read_keyframe_mapping(mapping_file):
    """
    Read keyframe_mapping.txt and return timestampâ†’frame_id and timestampâ†’filename mappings.
    
    Format: timestamp frame_id "original_filename.ext"
    
    Returns:
        tuple: (timestamp_to_frame_id dict, timestamp_to_filename dict)
    """
    timestamp_to_frame_id = {}
    timestamp_to_filename = {}
    
    with open(mapping_file, 'r') as f:
        for line in f:
            line = line.strip()
            # Skip comments, empty lines, and header
            if not line or line.startswith('#') or line.startswith('m-slam_file'):
                continue
            
            # Parse: timestamp frame_id "filename with spaces.ext"
            # Split only on first two spaces to preserve filename with spaces
            parts = line.split(None, 2)  # Split on whitespace, max 2 splits
            if len(parts) >= 3:
                timestamp = float(parts[0])
                frame_id = int(parts[1])
                # Remove quotes from filename
                original_filename = parts[2].strip('"')
                
                timestamp_to_frame_id[timestamp] = frame_id
                timestamp_to_filename[timestamp] = original_filename
    
    return timestamp_to_frame_id, timestamp_to_filename


def parse_colmap_images_txt(images_txt):
    """
    Parse COLMAP images.txt to extract image_id, pose, camera_id, and name.
    
    Returns list of dicts with keys: image_id, qw, qx, qy, qz, tx, ty, tz, camera_id, name, timestamp
    """
    images = []
    
    with open(images_txt, 'r') as f:
        lines = f.readlines()
    
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        
        # Skip empty lines and comments
        if not line or line.startswith('#'):
            i += 1
            continue
        
        # Parse image line
        parts = line.split()
        if len(parts) < 10:
            i += 1
            continue
        
        image_id = int(parts[0])
        qw, qx, qy, qz = map(float, parts[1:5])
        tx, ty, tz = map(float, parts[5:8])
        camera_id = int(parts[8])
        name = parts[9]
        
        # Extract timestamp from filename (e.g., "0.20000000298023224.png" â†’ 0.2)
        timestamp = float(Path(name).stem)
        
        images.append({
            'image_id': image_id,
            'qw': qw, 'qx': qx, 'qy': qy, 'qz': qz,
            'tx': tx, 'ty': ty, 'tz': tz,
            'camera_id': camera_id,
            'name': name,
            'timestamp': timestamp
        })
        
        # Skip second line (2D points - always empty in our case)
        i += 2
    
    return images


def write_colmap_images_txt_original(output_path, images_data):
    """
    Write COLMAP images.txt with original high-res filenames.
    
    Args:
        images_data: List of dicts with pose data and 'original_name' key
    """
    with open(output_path, 'w') as f:
        # Write header
        f.write("# Image list with two lines of data per image:\n")
        f.write("#   IMAGE_ID, QW, QX, QY, QZ, TX, TY, TZ, CAMERA_ID, NAME\n")
        f.write("#   POINTS2D[] as (X, Y, POINT3D_ID)\n")
        f.write(f"# Number of images: {len(images_data)}\n")
        f.write("# NOTE: This file uses ORIGINAL HIGH-RES image filenames\n")
        f.write("#       Generated by generate_original_images_colmap.py\n")
        
        for img in images_data:
            # Write image line
            f.write(f"{img['image_id']} ")
            f.write(f"{img['qw']} {img['qx']} {img['qy']} {img['qz']} ")
            f.write(f"{img['tx']} {img['ty']} {img['tz']} ")
            f.write(f"{img['camera_id']} {img['original_name']}\n")
            
            # Write empty second line (no 2D points)
            f.write("\n")
    
    print(f"âœ“ Wrote {len(images_data)} images to {output_path}")


def write_colmap_images_bin_original(output_path, images_data):
    """
    Write COLMAP images.bin in binary format with original filenames.
    
    Binary format:
        num_images (uint64)
        For each image:
            image_id (uint32)  # NOTE: uint32, not uint64!
            qw, qx, qy, qz (double[4])
            tx, ty, tz (double[3])
            camera_id (uint32)  # NOTE: uint32, not uint64!
            name (null-terminated string)
            num_points2D (uint64)
    """
    with open(output_path, 'wb') as f:
        # Write number of images
        f.write(struct.pack('Q', len(images_data)))  # uint64
        
        for img in images_data:
            # Write image_id (uint32)
            f.write(struct.pack('I', img['image_id']))
            
            # Write quaternion (qw, qx, qy, qz)
            f.write(struct.pack('d', img['qw']))
            f.write(struct.pack('d', img['qx']))
            f.write(struct.pack('d', img['qy']))
            f.write(struct.pack('d', img['qz']))
            
            # Write translation (tx, ty, tz)
            f.write(struct.pack('d', img['tx']))
            f.write(struct.pack('d', img['ty']))
            f.write(struct.pack('d', img['tz']))
            
            # Write camera_id (uint32)
            f.write(struct.pack('I', img['camera_id']))
            
            # Write image name (null-terminated string)
            name_bytes = img['original_name'].encode('utf-8') + b'\x00'
            f.write(name_bytes)
            
            # Write num_points2D (0)
            f.write(struct.pack('Q', 0))
    
    print(f"âœ“ Wrote {len(images_data)} images to {output_path}")


def write_full_mapping(output_path, images_data):
    """
    Write extended keyframe mapping file with original filenames included.
    
    Format: timestamp frame_id keyframe_name original_name
    """
    with open(output_path, 'w') as f:
        f.write("# Extended keyframe mapping: timestamp â†’ frame_id â†’ filenames\n")
        f.write("# Format: timestamp frame_id keyframe_name original_name\n")
        f.write(f"# Total keyframes: {len(images_data)}\n")
        f.write("# keyframe_name: downsampled PNG used by MASt3R-SLAM\n")
        f.write("# original_name: high-res source image for splatting\n")
        
        for img in images_data:
            f.write(f"{img['timestamp']} {img['frame_id']} {img['name']} {img['original_name']}\n")
    
    print(f"âœ“ Wrote extended mapping to {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Update COLMAP images files to use high-res image filenames",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example:
  python get_highres_images_colmap.py --dataset highres_Mars
  python get_highres_images_colmap.py --dataset highres_Mars --mslam_logs_dir /custom/path

This will:
  1. Backup images.txt/bin â†’ images_lowres.txt/bin
  2. Update images.txt/bin with high-res filenames from keyframe_mapping.txt
  3. Create keyframe_mapping_full.txt with extended info

Note: Filenames are read from keyframe_mapping.txt (which includes the original filenames)
"""
    )
    
    parser.add_argument(
        '--dataset',
        type=str,
        required=True,
        help='Dataset name (run directory in intermediate_data)'
    )
    parser.add_argument(
        '--mslam_logs_dir',
        type=str,
        default=None,
        help='Path to MASt3R-SLAM logs directory (default: auto-detect from intermediate_data)'
    )
    
    args = parser.parse_args()
    
    # Setup paths
    run_dir = INTERMEDIATE_DATA_ROOT / args.dataset
    
    if args.mslam_logs_dir:
        mslam_logs = Path(args.mslam_logs_dir)
    else:
        mslam_logs = run_dir / 'mslam_logs'
    
    mapping_file = mslam_logs / 'keyframe_mapping.txt'
    images_txt = run_dir / 'for_splat' / 'sparse' / '0' / 'images.txt'
    images_bin = run_dir / 'for_splat' / 'sparse' / '0' / 'images.bin'
    
    # Backup original files
    backup_txt = run_dir / 'for_splat' / 'sparse' / '0' / 'images_lowres.txt'
    backup_bin = run_dir / 'for_splat' / 'sparse' / '0' / 'images_lowres.bin'
    
    # Output will overwrite original images.txt/bin
    output_txt = images_txt
    output_bin = images_bin
    output_mapping = mslam_logs / 'keyframe_mapping_full.txt'
    
    # Validate inputs
    if not mapping_file.exists():
        raise FileNotFoundError(
            f"Keyframe mapping not found: {mapping_file}\n"
            f"Make sure you've run MASt3R-SLAM with the modified evaluate.py"
        )
    
    if not images_txt.exists():
        raise FileNotFoundError(
            f"COLMAP images.txt not found: {images_txt}\n"
            f"Make sure you've run cam_pose_keyframes_shuttle.py first"
        )
    
    if not images_bin.exists():
        raise FileNotFoundError(
            f"COLMAP images.bin not found: {images_bin}\n"
            f"Make sure you've run cam_pose_keyframes_shuttle.py first"
        )
    
    print(f"\n{'='*70}")
    print(f"Updating COLMAP images files with high-res filenames")
    print(f"{'='*70}")
    print(f"Dataset: {args.dataset}")
    print()
    
    # Step 0: Backup original images.txt/bin
    print("[0/4] Backing up original images.txt/bin...")
    shutil.copy2(images_txt, backup_txt)
    shutil.copy2(images_bin, backup_bin)
    print(f"  âœ“ Backed up to images_lowres.txt/bin")
    
    # Step 1: Read keyframe mapping (with original filenames)
    print("\n[1/4] Reading keyframe mapping with original filenames...")
    timestamp_to_frame_id, timestamp_to_filename = read_keyframe_mapping(mapping_file)
    print(f"  âœ“ Loaded {len(timestamp_to_filename)} keyframe mappings")
    
    # Step 2: Parse COLMAP images.txt
    print("\n[2/4] Parsing COLMAP images.txt...")
    images_data = parse_colmap_images_txt(images_txt)
    print(f"  âœ“ Loaded {len(images_data)} image poses")
    
    # Step 3: Match timestamps to original filenames from mapping
    print("\n[3/4] Matching keyframes to original filenames...")
    matched_count = 0
    
    for img in images_data:
        timestamp = img['timestamp']
        
        if timestamp not in timestamp_to_filename:
            print(f"  âš ï¸  Warning: No filename found for timestamp {timestamp}")
            continue
        
        # Get original filename directly from mapping
        original_filename = timestamp_to_filename[timestamp]
        frame_id = timestamp_to_frame_id[timestamp]
        
        img['original_name'] = original_filename
        img['frame_id'] = frame_id
        matched_count += 1
    
    print(f"  âœ“ Matched {matched_count}/{len(images_data)} keyframes to original filenames")
    
    if matched_count == 0:
        raise ValueError("No keyframes could be matched to original filenames!")
    
    # Step 4: Write output files (overwriting images.txt/bin)
    print("\n[4/4] Writing updated images.txt/bin files...")
    
    # Filter to only successfully matched images
    matched_images = [img for img in images_data if 'original_name' in img]
    
    write_colmap_images_txt_original(output_txt, matched_images)
    write_colmap_images_bin_original(output_bin, matched_images)
    write_full_mapping(output_mapping, matched_images)
    
    print(f"\n{'='*70}")
    print(f"âœ… Successfully updated COLMAP files with high-res filenames!")
    print(f"{'='*70}")
    print(f"\nUpdated files:")
    print(f"  - {output_txt} (original backed up as images_lowres.txt)")
    print(f"  - {output_bin} (original backed up as images_lowres.bin)")
    print(f"  - {output_mapping} (extended mapping file)")
    print(f"\nðŸ’¡ Next steps:")
    print(f"  1. Copy high-res images using copy_highres_keyframes.py")
    print(f"  2. Run Gaussian splatting - it will now use high-res images!")
    print(f"\nâš ï¸  Note: Filenames with spaces are fully supported by COLMAP")
    print()


if __name__ == '__main__':
    main()
