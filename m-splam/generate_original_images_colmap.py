#!/usr/bin/env python3
"""
generate_original_images_colmap.py

Generate COLMAP images_original.txt/bin files that reference the original high-resolution
image filenames instead of the downsampled timestamp-based keyframe names.

This enables using full-resolution images for Gaussian splatting while keeping the same
camera poses estimated by MASt3R-SLAM on downsampled images.

Input:
  - keyframe_mapping.txt: Maps timestamp ‚Üí frame_id (from MASt3R-SLAM)
  - Original images directory: Contains high-res source images
  - images.txt: COLMAP poses for downsampled keyframes

Output:
  - images_original.txt: COLMAP format with original filenames
  - images_original.bin: Binary version of above
  - keyframe_mapping_full.txt: Extended mapping with original filenames

Usage:
  python generate_original_images_colmap.py --dataset mars_johns_1 --images_path /path/to/original/images
  python generate_original_images_colmap.py --dataset mars_johns_1 --images_path /path/to/original/images --extension .jpg
"""

import argparse
import struct
import numpy as np
from pathlib import Path
from natsort import natsorted


INTERMEDIATE_DATA_ROOT = Path('/home/ben/encode/data/intermediate_data')


def read_keyframe_mapping(mapping_file):
    """
    Read keyframe_mapping.txt and return timestamp‚Üíframe_id mapping.
    
    Format: timestamp frame_id
    """
    mapping = {}
    with open(mapping_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split()
            if len(parts) >= 2:
                timestamp = float(parts[0])
                frame_id = int(parts[1])
                mapping[timestamp] = frame_id
    return mapping


def get_original_filenames(images_path, extension='.JPG'):
    """
    Get sorted list of original image filenames from the source directory.
    Uses natsort for proper numerical ordering (e.g., (9).JPG before (10).JPG).
    
    Returns list of Path objects.
    """
    images_path = Path(images_path)
    pattern = f"*{extension}"
    files = natsorted(list(images_path.glob(pattern)))
    
    if not files:
        raise ValueError(f"No images found matching {pattern} in {images_path}")
    
    return files


def parse_colmap_images_txt(images_txt):
    """
    Parse COLMAP images.txt to extract image_id, pose, camera_id, and name.
    
    Returns list of dicts with keys: image_id, qw, qx, qy, qz, tx, ty, tz, camera_id, name, timestamp
    """
    images = []
    
    with open(images_txt, 'r') as f:
        lines = f.readlines()
    
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        
        # Skip empty lines and comments
        if not line or line.startswith('#'):
            i += 1
            continue
        
        # Parse image line
        parts = line.split()
        if len(parts) < 10:
            i += 1
            continue
        
        image_id = int(parts[0])
        qw, qx, qy, qz = map(float, parts[1:5])
        tx, ty, tz = map(float, parts[5:8])
        camera_id = int(parts[8])
        name = parts[9]
        
        # Extract timestamp from filename (e.g., "0.20000000298023224.png" ‚Üí 0.2)
        timestamp = float(Path(name).stem)
        
        images.append({
            'image_id': image_id,
            'qw': qw, 'qx': qx, 'qy': qy, 'qz': qz,
            'tx': tx, 'ty': ty, 'tz': tz,
            'camera_id': camera_id,
            'name': name,
            'timestamp': timestamp
        })
        
        # Skip second line (2D points - always empty in our case)
        i += 2
    
    return images


def write_colmap_images_txt_original(output_path, images_data):
    """
    Write COLMAP images.txt with original high-res filenames.
    
    Args:
        images_data: List of dicts with pose data and 'original_name' key
    """
    with open(output_path, 'w') as f:
        # Write header
        f.write("# Image list with two lines of data per image:\n")
        f.write("#   IMAGE_ID, QW, QX, QY, QZ, TX, TY, TZ, CAMERA_ID, NAME\n")
        f.write("#   POINTS2D[] as (X, Y, POINT3D_ID)\n")
        f.write(f"# Number of images: {len(images_data)}\n")
        f.write("# NOTE: This file uses ORIGINAL HIGH-RES image filenames\n")
        f.write("#       Generated by generate_original_images_colmap.py\n")
        
        for img in images_data:
            # Write image line
            f.write(f"{img['image_id']} ")
            f.write(f"{img['qw']} {img['qx']} {img['qy']} {img['qz']} ")
            f.write(f"{img['tx']} {img['ty']} {img['tz']} ")
            f.write(f"{img['camera_id']} {img['original_name']}\n")
            
            # Write empty second line (no 2D points)
            f.write("\n")
    
    print(f"‚úì Wrote {len(images_data)} images to {output_path}")


def write_colmap_images_bin_original(output_path, images_data):
    """
    Write COLMAP images.bin in binary format with original filenames.
    
    Binary format:
        num_images (uint64)
        For each image:
            image_id (uint32)  # NOTE: uint32, not uint64!
            qw, qx, qy, qz (double[4])
            tx, ty, tz (double[3])
            camera_id (uint32)  # NOTE: uint32, not uint64!
            name (null-terminated string)
            num_points2D (uint64)
    """
    with open(output_path, 'wb') as f:
        # Write number of images
        f.write(struct.pack('Q', len(images_data)))  # uint64
        
        for img in images_data:
            # Write image_id (uint32)
            f.write(struct.pack('I', img['image_id']))
            
            # Write quaternion (qw, qx, qy, qz)
            f.write(struct.pack('d', img['qw']))
            f.write(struct.pack('d', img['qx']))
            f.write(struct.pack('d', img['qy']))
            f.write(struct.pack('d', img['qz']))
            
            # Write translation (tx, ty, tz)
            f.write(struct.pack('d', img['tx']))
            f.write(struct.pack('d', img['ty']))
            f.write(struct.pack('d', img['tz']))
            
            # Write camera_id (uint32)
            f.write(struct.pack('I', img['camera_id']))
            
            # Write image name (null-terminated string)
            name_bytes = img['original_name'].encode('utf-8') + b'\x00'
            f.write(name_bytes)
            
            # Write num_points2D (0)
            f.write(struct.pack('Q', 0))
    
    print(f"‚úì Wrote {len(images_data)} images to {output_path}")


def write_full_mapping(output_path, images_data):
    """
    Write extended keyframe mapping file with original filenames included.
    
    Format: timestamp frame_id keyframe_name original_name
    """
    with open(output_path, 'w') as f:
        f.write("# Extended keyframe mapping: timestamp ‚Üí frame_id ‚Üí filenames\n")
        f.write("# Format: timestamp frame_id keyframe_name original_name\n")
        f.write(f"# Total keyframes: {len(images_data)}\n")
        f.write("# keyframe_name: downsampled PNG used by MASt3R-SLAM\n")
        f.write("# original_name: high-res source image for splatting\n")
        
        for img in images_data:
            f.write(f"{img['timestamp']} {img['frame_id']} {img['name']} {img['original_name']}\n")
    
    print(f"‚úì Wrote extended mapping to {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Generate COLMAP files with original high-res image filenames",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example:
  python generate_original_images_colmap.py \\
      --dataset mars_johns_1 \\
      --images_path /home/ben/encode/data/mars_johns/left \\
      --extension .JPG

This creates:
  - images_original.txt: COLMAP format with original filenames
  - images_original.bin: Binary version
  - keyframe_mapping_full.txt: Complete timestamp‚Üífilename mapping
"""
    )
    
    parser.add_argument(
        '--dataset',
        type=str,
        required=True,
        help='Dataset name (run directory in intermediate_data)'
    )
    parser.add_argument(
        '--images_path',
        type=str,
        required=True,
        help='Path to directory containing original high-resolution images'
    )
    parser.add_argument(
        '--extension',
        type=str,
        default='.JPG',
        help='Image file extension (default: .JPG, can use .jpg, .png, etc.)'
    )
    parser.add_argument(
        '--mslam_logs_dir',
        type=str,
        default=None,
        help='Path to MASt3R-SLAM logs directory (default: auto-detect from intermediate_data)'
    )
    
    args = parser.parse_args()
    
    # Setup paths
    run_dir = INTERMEDIATE_DATA_ROOT / args.dataset
    
    if args.mslam_logs_dir:
        mslam_logs = Path(args.mslam_logs_dir)
    else:
        mslam_logs = run_dir / 'mslam_logs'
    
    mapping_file = mslam_logs / 'keyframe_mapping.txt'
    images_txt = run_dir / 'for_splat' / 'sparse' / '0' / 'images.txt'
    
    output_txt = run_dir / 'for_splat' / 'sparse' / '0' / 'images_original.txt'
    output_bin = run_dir / 'for_splat' / 'sparse' / '0' / 'images_original.bin'
    output_mapping = mslam_logs / 'keyframe_mapping_full.txt'
    
    # Validate inputs
    if not mapping_file.exists():
        raise FileNotFoundError(
            f"Keyframe mapping not found: {mapping_file}\n"
            f"Make sure you've run MASt3R-SLAM with the modified evaluate.py"
        )
    
    if not images_txt.exists():
        raise FileNotFoundError(
            f"COLMAP images.txt not found: {images_txt}\n"
            f"Make sure you've run cam_pose_keyframes_shuttle.py first"
        )
    
    print(f"\n{'='*70}")
    print(f"Generating COLMAP files with original image names")
    print(f"{'='*70}")
    print(f"Dataset: {args.dataset}")
    print(f"Original images: {args.images_path}")
    print(f"Extension: {args.extension}")
    print()
    
    # Step 1: Read keyframe mapping
    print("[1/5] Reading keyframe mapping...")
    timestamp_to_frame_id = read_keyframe_mapping(mapping_file)
    print(f"  ‚úì Loaded {len(timestamp_to_frame_id)} keyframe mappings")
    
    # Step 2: Get original image filenames
    print("\n[2/5] Reading original image filenames...")
    original_files = get_original_filenames(args.images_path, args.extension)
    print(f"  ‚úì Found {len(original_files)} original images")
    
    # Step 3: Parse COLMAP images.txt
    print("\n[3/5] Parsing COLMAP images.txt...")
    images_data = parse_colmap_images_txt(images_txt)
    print(f"  ‚úì Loaded {len(images_data)} image poses")
    
    # Step 4: Match timestamps to original filenames
    print("\n[4/5] Matching keyframes to original images...")
    matched_count = 0
    
    for img in images_data:
        timestamp = img['timestamp']
        
        if timestamp not in timestamp_to_frame_id:
            print(f"  ‚ö†Ô∏è  Warning: No frame_id found for timestamp {timestamp}")
            continue
        
        frame_id = timestamp_to_frame_id[timestamp]
        
        if frame_id >= len(original_files):
            print(f"  ‚ö†Ô∏è  Warning: frame_id {frame_id} out of range (have {len(original_files)} images)")
            continue
        
        # Get original filename
        original_file = original_files[frame_id]
        img['original_name'] = original_file.name
        img['frame_id'] = frame_id
        matched_count += 1
    
    print(f"  ‚úì Matched {matched_count}/{len(images_data)} keyframes to original images")
    
    if matched_count == 0:
        raise ValueError("No keyframes could be matched to original images!")
    
    # Step 5: Write output files
    print("\n[5/5] Writing output files...")
    
    # Filter to only successfully matched images
    matched_images = [img for img in images_data if 'original_name' in img]
    
    write_colmap_images_txt_original(output_txt, matched_images)
    write_colmap_images_bin_original(output_bin, matched_images)
    write_full_mapping(output_mapping, matched_images)
    
    print(f"\n{'='*70}")
    print(f"‚úÖ Successfully generated COLMAP files with original names!")
    print(f"{'='*70}")
    print(f"\nOutput files:")
    print(f"  - {output_txt}")
    print(f"  - {output_bin}")
    print(f"  - {output_mapping}")
    print(f"\nüí° Usage:")
    print(f"  1. Copy/convert original high-res images to: {run_dir / 'for_splat' / 'images_highres'}/")
    print(f"  2. Update splatting script to use images_original.txt instead of images.txt")
    print(f"  3. Point splatting to images_highres/ directory")
    print()


if __name__ == '__main__':
    main()
