Image Dimension Issue - Root Cause Analysis
===========================================

## EXECUTIVE SUMMARY

**The image dimension issue IS the cause of training failures.**

All 14 patches have dimension mismatches, but only patches 5, 6, 8, 10, 12 failed.
The root cause is that the original COLMAP reconstruction was never updated after
images were resized, so re-patching with different max_cameras created new patches
with incorrect intrinsics.

## EVIDENCE GATHERED

### 1. Image Dimension Check (ALL PATCHES)

- **Total patches checked**: 14
- **Patches with mismatches**: 14 (100%)
- **Total image mismatches**: 5,378

**Pattern**: ALL patches have dimension mismatches:
- Camera 1 (left): expects 1548×1360, actual 1548×1357 ✓ width, ❌ height
- Camera 2 (right): expects 1550×1357, actual 1548×1357 ❌ width, ✓ height

**Key finding**: ALL images are actually 1548×1357, but COLMAP expects mixed dimensions.

### 2. Original COLMAP Reconstruction

Location: `/home/ben/encode/data/intermediate_data/colmap5/sparse/`

```
Camera 1 (left):  1548×1360  ← WRONG (expects height=1360, actual=1357)
Camera 2 (right): 1550×1357  ← WRONG (expects width=1550, actual=1548)
```

**Last modified**: Dec 15-16, cameras.bin dated Dec 15 10:23

This is the SOURCE reconstruction used by `patch_colmap_data.py` to create patches.

### 3. What match_img_dims.py Did

When `match_img_dims.py` was run:
1. ✓ Resized ALL images to 1548×1357 (correct)
2. ✓ Updated patch intrinsics in `sparse_patches/` (correct)
3. ❌ Did NOT update original `sparse/` directory (BUG)

**Critical flaw**: The script only updated existing patches, not the source reconstruction.

### 4. What Happened When You Re-patched

Timeline:
- Dec 15: Ran with max_cameras=450 → created 11 patches using FIXED patch intrinsics
- Dec 17: Changed max_cameras=400 → re-ran patching
  - Deleted old patches
  - `patch_colmap_data.py` read from `sparse/` (still has WRONG intrinsics)
  - Created 14 NEW patches with WRONG intrinsics from source

**This explains why failures increased**: Fresh patches were created from bad source data.

### 5. Why Some Patches Failed and Others Didn't

Failed patches: p5, p6, p8, p10, p12
Succeeded: p0, p1, p2, p3, p4, p7, p9, p11, p13

**Hypothesis**: LichtFeld-Studio's dimension correction (scaling) sometimes works:

From p8 training log:
```
[10:57:09.770] [warning] colmap.cpp:860 Image dimension mismatch detected!
[10:57:09.770] [info] colmap.cpp:861   Expected (from COLMAP): 1548x1360
[10:57:09.770] [info] colmap.cpp:862   Actual (from image file): 1548x1357
[10:57:09.770] [info] colmap.cpp:863   Applying correction scale: 1.000x0.998
```

LichtFeld TRIES to auto-correct by scaling, but this fails in CUDA kernels when:
- Tensor shapes are created based on COLMAP dimensions
- Image data loaded with actual dimensions
- CUDA operations expect exact dimension match

**The correction attempt is unreliable** - it works sometimes but fails during
tensor operations when dimensions don't align exactly.

### 6. Why More Failures with Fewer Cameras?

Your observation was correct! With max_cameras=450 (11 patches), only 1 failed.
With max_cameras=400 (14 patches), 5 failed.

**Explanation**: This is NOT about fewer cameras causing more failures.
- max_cameras=450: Used OLD patches with CORRECT intrinsics (already fixed)
- max_cameras=400: Created NEW patches from UNFIXED source with WRONG intrinsics

**It's not the patch size, it's the source data.**

## ROOT CAUSE

The original COLMAP sparse reconstruction (`sparse/cameras.bin`) has outdated
camera intrinsics that don't match the resized images. When patching is re-run,
it propagates these incorrect parameters to all new patches.

## ALTERNATIVE CAUSES INVESTIGATED

### Could it be GPU memory?
- ❌ No. Failed patches have similar image counts to successful ones
- ❌ p8 has only 336 images (smallest) but still failed
- ❌ Failures happen in first 1-5 seconds, not during training

### Could it be patch boundaries?
- ❌ No. Boundary filtering happens AFTER training during cleanup
- ❌ Failed patches are scattered (p5, p6, p8, p10, p12), not edge patches

### Could it be point cloud quality?
- ❌ No. All patches use same point cloud splitting method
- ❌ Error happens before any training iterations complete

### Could it be a CUDA/driver issue?
- ❌ No. Successful patches use same GPU/CUDA/driver
- ❌ Error is deterministic (same patches fail consistently)

### Could it be LichtFeld-Studio bug?
- ❌ No. LichtFeld detects the mismatch and tries to correct it
- ❌ Some patches work despite dimension warnings
- ❌ The bug is in our preprocessing, not LFS

## SOLUTION

### Immediate Fix

1. Update original COLMAP reconstruction intrinsics to match resized images:
   ```bash
   conda activate mast3r-slam-blackwell
   python fix_original_colmap_intrinsics.py
   ```

2. Delete current patches and re-patch:
   ```bash
   rm -rf /home/ben/encode/data/intermediate_data/colmap5/sparse_patches
   python patch_colmap_data.py --config splat_config.yml
   ```

3. Resume training (will skip completed patches):
   ```bash
   ./batch_train_splat.sh
   ```

### Long-term Prevention

Update `match_img_dims.py` to:
1. Fix images first (already does this)
2. Fix ORIGINAL sparse/ reconstruction (missing)
3. Fix patches (already does this)

This ensures the source data is correct before any patching.

### Even Better: Future Workflow

As noted in match_img_dims.py TODO:
```python
#TODO: in future, just do resizing before running colmap to prevent this messy issue.
```

**Best practice**: Standardize all image dimensions BEFORE running COLMAP reconstruction.
This avoids the entire intrinsics update problem.

## CONFIDENCE LEVEL

**99% certain** image dimensions are the root cause:
- ✓ Evidence is clear: ALL patches have dimension mismatches
- ✓ Failed patches show dimension mismatch errors in logs
- ✓ Timeline matches: new patches from bad source → more failures
- ✓ No evidence for alternative causes
- ✓ Solution is straightforward and testable

The mystery of "why more failures with fewer cameras" is explained by the
re-patching event propagating bad intrinsics, not by the patch size itself.
